Developer Guide
Task Manager Console Application (C++)
Table of Contents
Project Overview

Prerequisites

Project Structure

Building the Project

Coding Standards

Design Principles

Modules Overview

Adding Features

Running Tests

Version Control Guidelines

Contributing

Contact

Project Overview
This project is a console-based Task Manager application built in C++. It supports creating, viewing, updating, deleting, and filtering tasks with persistent storage.

It demonstrates software construction best practices, modular design, and unit testing with Google Test.

Prerequisites
C++17 compatible compiler (g++, clang++, MSVC)

CMake (optional but recommended)

Google Test framework installed for unit testing

Git for version control

Project Structure
bash
Copy
Edit
/TaskManager
|-- main.cpp               # Entry point, CLI menu and interaction
|-- task.cpp/h             # Task class implementation and declaration
|-- task_manager.cpp/h     # Manages collection of tasks and operations
|-- file_manager.cpp/h     # Handles low-level file I/O operations
|-- storage_manager.cpp/h  # Save/load tasks to/from files
|-- filter_tasks.cpp/h     # Filters tasks by status (completed/incomplete)
|-- date_util.cpp/h        # Date validation and utilities
|-- search.cpp/h           # Search utilities for tasks
|-- test_task.cpp          # Unit tests for Task class
|-- test_task_manager.cpp  # Unit tests for TaskManager class
|-- CMakeLists.txt         # Build configuration (optional)
|-- README.md              # Project overview and usage
|-- developer_guide.md     # This document
Building the Project
Using g++ directly:
bash
Copy
Edit
g++ -std=c++17 main.cpp task.cpp task_manager.cpp file_manager.cpp storage_manager.cpp filter_tasks.cpp date_util.cpp search.cpp -o TaskManager
Using CMake (recommended)
bash
Copy
Edit
mkdir build
cd build
cmake ..
make
./TaskManager
Coding Standards
Follow Google C++ Style Guide for naming, formatting, and comments.

Use camelCase for variables and methods.

Classes use PascalCase.

Use const correctness where applicable.

Keep functions short and modular.

Add comments for complex logic and public APIs.

Apply SOLID principles: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.

Design Principles
Modular Design: Separate concerns into classes and modules.

Encapsulation: Use private members and public methods.

Separation of Concerns: UI logic separated from business logic.

Persistence: Storage handled via file management modules.

Testability: Code written to allow unit testing of individual components.

Modules Overview
Module	Responsibility
main.cpp	CLI menu, user input handling
Task	Represents individual tasks
TaskManager	CRUD operations on task collections
FileManager	Low-level file reading/writing
StorageManager	Loading and saving tasks to persistent storage
FilterTasks	Filtering tasks by status
DateUtil	Date validation and utilities
Search	Search tasks by ID or criteria

Adding Features
Identify the relevant module.

Follow existing coding and documentation style.

Write unit tests for new features.

Run all existing and new tests.

Submit code via a Pull Request with description.

Running Tests
Ensure Google Test is installed.

Compile tests linking against gtest and your code.

Run the tests executable.

Example:

bash
Copy
Edit
g++ -std=c++17 test_task.cpp task.cpp -lgtest -lgtest_main -pthread -o test_task
./test_task
Version Control Guidelines
Use Git for source control.

Commit early and often with clear messages.

Branch per feature or bugfix.

Use meaningful commit messages:
Add: Update task functionality with validation

Push branches and create Pull Requests for reviews.

Contributing
Contributions are welcome! Please fork the repository, make your changes, and submit a pull request. Follow the coding standards and include tests for your changes.

Contact
For questions or help, contact the maintainer:
Your Name â€” your.email@example.com
